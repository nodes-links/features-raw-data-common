{"version":3,"file":"primavera-parsing-common.service.js","sourceRoot":"","sources":["../../services/primavera-parsing-common.service.ts"],"names":[],"mappings":";;;AAIA;;;GAGG;AACH,MAAa,6BAA6B;IACxC;;;;OAIG;IACH,YAAoB,QAA8B;QAA9B,aAAQ,GAAR,QAAQ,CAAsB;IAAG,CAAC;IAEtD;;;;;OAKG;IACI,YAAY,CAAC,OAAqB;QACvC,IAAI;YACF,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;YACf,IAAI,OAAO,GAAkB,EAAE,CAAC;YAChC,IAAI,CAAC,QAAQ,CAAC,qBAAqB,EAAE,CAAC;YACtC,IAAI,YAAY,GAAG,KAAK,CAAC;YACzB,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;gBACzB,MAAM,OAAO,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;gBACvB,IAAI,OAAO,KAAK,IAAI,EAAE;oBACpB,YAAY;oBACZ,IAAI,CAAC,eAAe,CAAC,EAAE,KAAK,EAAE,GAAe,CAAC,CAAC;iBAChD;qBAAM,IAAI,OAAO,KAAK,IAAI,EAAE;oBAC3B,cAAc;oBACd,OAAO,GAAG,IAAI,CAAC,gBAAgB,CAAC,GAAe,EAAE,KAAK,CAAC,CAAC;iBACzD;qBAAM,IAAI,OAAO,KAAK,IAAI,EAAE;oBAC3B,WAAW;oBACX,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;oBACzC,YAAY,GAAG,IAAI,CAAC;iBACrB;YACH,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,YAAY;gBAAE,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;YACzE,IAAI,CAAC,QAAQ,CAAC,sBAAsB,EAAE,CAAC;SACxC;QAAC,OAAO,KAAK,EAAE;YACd,MAAM,KAAK,CAAC;SACb;IACH,CAAC;IAED;;;;;OAKG;IACK,cAAc,CAAC,OAAiB,EAAE,GAAkC,EAAE,KAAa;QACzF,MAAM,MAAM,GAAG,EAAE,CAAC;QAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACvC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;SACjC;QACD,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IACtC,CAAC;IAED;;;;OAIG;IACK,gBAAgB,CAAC,GAAa,EAAE,KAAa;QACnD,MAAM,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAC7B,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QACzC,OAAO,OAAO,CAAC;IACjB,CAAC;IAED;;;;OAIG;IACK,eAAe,CAAC,KAAa,EAAE,GAAa;QAClD,MAAM,KAAK,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;QACrB,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IACvC,CAAC;CACF;AA3ED,sEA2EC","sourcesContent":["import * as _ from 'lodash';\nimport { IPapaResults } from '../interfaces/papa-results';\nimport { RawDataCommonService } from './raw-data-common.service';\n\n/**\n * This service is responsible for converting the result produced by the (XER -> arrays) parsing process\n * into raw/tabular-friendly and graph-friendly formats and emitting it to the corresponding services.\n */\nexport class PrimaveraParsingCommonService {\n  /**\n   * Creates an instance of PrimaveraParsingCommonService.\n   *\n   * @memberof PrimaveraParsingCommonService\n   */\n  constructor(private _rawData: RawDataCommonService) {}\n\n  /**\n   * Each row is processed in sequence and the tables/headers/rows are extracted. For examples of a primavera files see\n   * [here](https://drive.google.com/drive/folders/1-hNWs8TBskLEMLuJiplfyF7cBJ3iEEHc). For details on the primavera export\n   * schema see [here](https://docs.oracle.com/cd/E38975_01/English/Mapping_and_Schema/Data_Mapping_Docs/OdsFieldMapTable.html).\n   * @param results The results returned from parsing the primavera file into an array of arrays.\n   */\n  public parseResults(results: IPapaResults) {\n    try {\n      let index = -1;\n      let headers: Array<string> = [];\n      this._rawData.startRawDataIngestion();\n      let foundDataRow = false;\n      results.data.forEach(row => {\n        const rowType = row[0];\n        if (rowType === '%T') {\n          // Table row\n          this.processTableRow(++index, row as string[]);\n        } else if (rowType === '%F') {\n          // Headers row\n          headers = this.processHeaderRow(row as string[], index);\n        } else if (rowType === '%R') {\n          // Data row\n          this.processDataRow(headers, row, index);\n          foundDataRow = true;\n        }\n      });\n      if (!foundDataRow) throw new Error('No project data present in the XER');\n      this._rawData.finishRawDataIngestion();\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Processes a new data row.\n   * @param headers The headers row is used to get the keys for the row object to be produced.\n   * @param row The row data is used to get the values for the row object to be produced.\n   * @param index The index of the table this row belongs to.\n   */\n  private processDataRow(headers: string[], row: (string | number | boolean)[], index: number) {\n    const newRow = {};\n    for (let i = 0; i < headers.length; i++) {\n      newRow[headers[i]] = row[i + 1];\n    }\n    this._rawData.addRow(index, newRow);\n  }\n\n  /**\n   * Processes the header row for the table at the given index.\n   * @param row The row containing the headers as an array of strings.\n   * @param index The index of the table these are the headers of.\n   */\n  private processHeaderRow(row: string[], index: number): string[] {\n    const headers = row.slice(1);\n    this._rawData.addHeaders(index, headers);\n    return headers;\n  }\n\n  /**\n   * Processes the row corresponding to the start of a table having the given index.\n   * @param index The index of the table.\n   * @param row The row corresponding to the table. This is where the table title is stored as the entry at index 1.\n   */\n  private processTableRow(index: number, row: string[]) {\n    const title = row[1];\n    this._rawData.addTable(index, title);\n  }\n}\n"]}